<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Channels 0.8</title>
<style><!-- 
body {
	margin-left: 10%;
	margin-right: 10%;
	padding: 20pt;
	padding-top: 10pt;
	background: rgb(255,255,255);
	font:  10.5pt/15pt "Helvetica",Helvetica,sans-serif;
	color: rgb(80,80,80);
}

h1, h2, h3, h4 {
	font-family: "Trebuchet MS",Helvetica,sans-serif;
	color: rgb(22, 130, 178);
	font-weight: normal;
	padding-top: 0.5em;
	cursor: pointer;
}

hr {
	color: rgb(150, 220, 238);
	background: rgb(150, 220, 238);
	height: 1px;
	border: 0;
}


b {
	color: rgb(22,130,178);
}

strong {
	color: rgb(103,183,0);
}


a:link, a:active, a:visited {
	color: rgb(22,130,178);
	text-decoration: none;
}

a:hover {
	text-decoration: none;
	background-color: #dbecf4;
}

aimg {
	border: 0;
}

#header, #footer {
	font-size: 7pt;
	clear: both;
	width: 100%;
	color: rgb(177,208,223);
}

.kiwiContent {
	text-align: left;
}


#footer {
	padding-top:  30pt;
	text-align: right;
}

/*  Kiwi-specific  */

.title {
	margin-bottom: 0;
}

.kiwiMeta {
	max-width: 700px;
	padding: 5pt;
	margin-bottom:  2em;
	border-top:  1px solid rgb(150, 220, 238);
	background-color: rgb(250,250,250);
}

.kiwiMeta tr td {
	color: rgb(22, 130, 178);
}

.kiwiMeta tr td.name {
	font-weight: bold;
}

.kiwiContent {
	max-width: 700px;
}

.kiwiContent .heading .number {
	padding-right: 8pt;
}

.kiwiContent .heading .number .lastDot {
	display: none;
}


.kiwiContent .heading .number .level0 .lastDot {
	display: inline;
}

.kiwiContent h1 {
	font-size: 1.8em;
	font-weight: bold;
	margin-top: 1.5em;
	padding-bottom: 0.5em;
	border-bottom:  1px dotted rgb(150, 220, 238);
}

.kiwiContent h2 {
	font-size: 1.4em;
	font-weight: bold;
	padding-bottom: 0.5em;
	border-bottom:  1px dotted rgb(150, 220, 238);
}

.kiwiContent h3 {
	font-size: 1.2em;
	font-weight: normal;
}

.kiwiContent pre {
	padding: 5pt;
	border:  1px solid rgb(150, 220, 238);
	padding-left: 20pt;
	background-color: rgb(240,240,250);
	font-size: 8pt;
	color: rgb(22,130,178);
}

.kiwiContent code {
	font-size: 8pt;
	background-color: rgb(240,240,250);
}

.kiwiContent dt {
	color: rgb(22,130,178);
	font-weight: bold;
}

.kiwiContent dd {
	border-left:  1px solid rgb(150, 220, 238);
	padding-left: 20pt;
	margin-bottom: 2em;
}

.kiwiContent dd pre {
}

.kiwiContent ul {
	padding-top: 0em;
	margin-top: 0em;
}

.kiwiContent ul li {
	padding-bottom: 0.2em;
}

.kiwiContent ul li.todo {
	list-style-type: square;
}

.kiwiContent ul li.todo.done {
	text-decoration: line-through;
}

.kiwiContent table {
	border:  1px solid rgb(150, 220, 238);
	padding: 0pt;
}

.kiwiContent table caption {
	font-family: serif;
	padding-top: 1em;
	padding-bottom: 0.5em;
	font-style: italic;
	font-size: 90%;
	color: rgb(22, 130, 178);
}

.kiwiContent table tbody {
}

.kiwiContent table tr {
	margin: 0;
}

.kiwiContent table tr td {
	margin: 0;
	padding: 5pt;
	font-size: 90%;
	min-width: 125px;
	background-color: rgb(250,250,250);
	border-bottom: 1px solid rgb(150, 220, 238);
}

.kiwiContent table tr td.lastRow {
	border-bottom: none;
}

.kiwiContent table tr td.lastCol {
	border-right: none;
}

.kiwiContent table tr.even td {
	background-color: #FEFEFE;

}

.kiwiContent table tr.odd td {
	background-color: rgb(240,240,240);
}

.kiwiContent .term {
	color: rgb(22, 130, 178);
	background: rgb(240, 250, 256);
}

.kiwiContent .quote {
	font-style: italic;
	color: rgb(120, 120, 120);
}

.kiwiContent .citation {
	font-style: italic;
	color: rgb(120, 120, 120);
}

.kiwiContent div[class^="ann"] {
	margin-top: 5pt;
	margin-bottom: 5pt;
	padding: 5pt;
	padding-left: 20pt;
	color: rgb(100, 100, 100);
}

.kiwiContent div[class^="ann"] .title {
	font-weight: bold;
}

.kiwiContent .annNote {
	border:  1px solid rgb(103,183,0);
	margin-top: 5pt;
	margin-bottom: 5pt;
	padding: 5pt;
	padding-left: 20pt;
	background: #fffbe4;
	color: rgb(100, 100, 100);
	border:  1px solid #dedac3;
}

.kiwiContent .annNote .title {
	font-weight: bold;
	display: none;
}

.kiwiReferences {
	font:  8pt/12pt "Lucida Grande",Lucida,sans-serif;
	margin-top: 10pt;
	padding: 5pt;
	border-top:  1px solid rgb(200, 200, 200);
	background-color: rgb(250,250,250);
	color: rgb(200, 200, 200);
	font-size: 8pt;
}
.kiwiReferences a:link, .kiwiReferences a:active, .kiwiReferences a:visited {
	color: rgb(150,150,150);
}

.kiwiReferences .entry {
	padding-top: 5pt;
	clear: both;
}

.kiwiReferences .entry .name {
	float: left;
	font-weight: bold;
	padding-right: 5pt;
}

.kiwiReferences .entry .content {
	text-align: right;
}

 --></style>
</head>
<body>
<div
	class="title"><h1>Channels 0.8</h1><h2>Developer Manual</h2></div><table class='kiwiMeta'><tr><td width='0px' class='name'>Author</td><td width='100%' class='value'>Sebastien Pierre &lt;sebastien@ivy.fr&gt;</td></tr><tr><td width='0px' class='name'>Revision</td><td width='100%' class='value'>12-Nov-2007</td></tr></table>
<div class="kiwiContent"><div class='content'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span>The problem</h1><div class="level1"></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">2<span class="lastDot dot">.</span></span></span>Channels API</h1><div class="level1"><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">1<span class="lastDot dot">.</span></span></span>Futures API</h2><div class="level2"><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">1<span class="dot">.</span></span><span class="level2">1<span class="lastDot dot">.</span></span></span>Channels API</h3><div class="level3"></div></div></div></div></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">3<span class="lastDot dot">.</span></span></span>Burst Channel Protocol</h1><div class="level1"><p>Burst channels is an easy way to do HTTP tunneling over HTTP. The idea is that when you have a lot of tiny requests to send to the server, it is may be better to group them as a larger request, so that you don't pay the overhead of multiplied latency.</p><p>For instance, if you have to send 10 requests, and you have a 100ms latency to the server, you'll end up having 1000ms total latency, while when using burst channels, you could keep the 100ms latency.</p><p>The burst channel protocol is designed for JSON-based communication between client and server. As opposed to plain tunneling of requests, where you'd expect requests and responses to be embedded "raw" in composite request and responses, the burst channel protocol specifies that only requests are embedded 'raw' (because server parse requests) while the responses are embedded as JSON maps (because clients should not spend time parsing requests).</p><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">1<span class="lastDot dot">.</span></span></span>Request format</h2><div class="level2"><p>The Burst Channel protocol is modeled after the MIME RFC <a href="#RFC1341" class="internal">RFC1341</a>]. The idea is that the client will simply embed each request as an individual body in a <span class='term'>composite request</span>. The only difference with RFC1341 is that we don't use the content-type header to identify boundary, but we use the 'X-Channel-Boundary' specific header (to make things easier for both client and server).</p><pre>+---------------------------------------------------------------+
| GET         /url/supporting/burst/channel                     |
+---------------------------------------------------------------+
| X-Channel-Boundary: 8&lt;-----BURST-CHANNEL-REQUEST------        |
| X-Channel-Type: burst                                         |
| X-Channel-Requests: 4                                         |
+---------------------------------------------------------------+
| HTTP REQUEST 1                                                |
| ............................................................. |
| 8&lt;-----BURST-CHANNEL-REQUEST------                            |
| ............................................................. |
| HTTP REQUEST 2                                                |
| ............................................................. |
| 8&lt;-----BURST-CHANNEL-REQUEST------                            |
| ............................................................. |
| HTTP REQUEST 4                                                |
+---------------------------------------------------------------+</pre><p>Each HTTP request is given as-is, including request URI, headers and body. The only thing to watch for is to avoid conflicts between boundary and request content (but this is the problem of the client).</p><p>Aside from that, it is a good idea to add an <code>X-Channel-Type:burst</code> header to the requests headers, just to be more explicit (and give a chance to reverse proxies to direct the burst requests to the appropriate server)&ndash;but severs should not require that field.</p><p>The optional <code>X-Channel-Requests</code> field can also be added to indicate how many requests are expected to be found in the request bodies. This is only useful for debugging purposes, as HTTP requests are expected to arrive completely.</p><p>There is no other particular requirement for the URL either, it is more a matter of convention. It's generally OK to provide a single URL that processes burst channels requests. In some cases, you might prefer to partition your site and provide different URLs that can handle burst channels.</p><p>It may be good to mention that in the HTTP spec, the request, headers and body must be separated by CR/LF (<code>\r\n</code>), so every request should look like:</p><pre>REQUEST
\r\n
HEADER\n
HEADER\n
\r\n
BODY\n</pre><p>in case you don't have headers, it would look like</p><pre>REQUEST
\r\n
\r\n
BODY\n</pre></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">2<span class="lastDot dot">.</span></span></span>Response format</h2><div class="level2"><p>As for requests, responses are embedded in a composite response, the main difference being that responses are embedded as <span class='term'>json maps</span> (as opposed to raw texT). The only additional constraint to respect here is to make sure the ordering of responses is the same as the ordering of requests.</p><pre>+---------------------------------------------------------------+
| HTTP 200 OK                                                   |
+---------------------------------------------------------------+
| X-Channel-Boundary: 8&lt;-----BURST-CHANNEL-RESPONSE------       |
| X-Channel-Responses: 4                                        |
+---------------------------------------------------------------+
| HTTP RESPONSE 1                                               |
| ............................................................. |
| 8&lt;-----BURST-CHANNEL-RESPONSE------                           |
| ............................................................. |
| HTTP RESPONSE 2                                               |
| ............................................................. |
| 8&lt;-----BURST-CHANNEL-RESPONSE------                           |
| ............................................................. |
| HTTP RESPONSE 4                                               |
+---------------------------------------------------------------+</pre><p>The optional <code>X-Channel-Responses</code> plays the same role as <code>X-Channel-Requests</code> and is only useful for debugging purposes.</p><p>As we mentioned, the content of <code>HTTP RESPONSE</code> is not the raw response : to save unnecessary parsing time on the client-side, the response is already given as JSON structure, with the following fields:</p><ul><li><code>status</code> the HTTP status code, as an integer </li><li><code>reason</code>, the HTTP reason, as a string </li><li><code>headers</code>, the HTTP heads, as an array or <code>[name,value]</code> </li><li><code>body</code>, the HTTP body, as a string</li></ul><p>An example response would be:</p><pre>{
  "status":200,
  "reason":"OK",
  "headers":[["Content-Type","application/json"]],
  "body":'["hello","world"]'
}</pre><p>You're not required to specify all the headers in the 'headers' field, as the client is expected to first look in the embedded response headers, and if the header is not found, it will look in the parent response header (but generally, only 'Content-Type' will be useful).</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">3<span class="lastDot dot">.</span></span></span>Expected client behaviour</h2><div class="level2"><p>The client can choose whether he wants to send the request all at once or if he will "stream" the bodies, meaning that there may be some delay between the sending of each body. However, this is unlikely to happen as web browsers do not support streaming of request bodies.</p><p>Clients should take advantage of response streaming and start to process the responses even if all the responses have not been received.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">4<span class="lastDot dot">.</span></span></span>Expected server behaviour</h2><div class="level2"><p>Conversely, the server can choose between waiting for all the requests to be processed to before sending the response, or to send the responses as soon as they are available, provided the ordering is kept.</p><p>The optimal behaviour would be to start processing the requests as soon as they are available, and to stream the responses as soon as they are available and in order.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">5<span class="lastDot dot">.</span></span></span>Possible extensions</h2><div class="level2"><p>One of the obvious extensions to burst channels is to do simple HTTP streaming, where the client sends only one request, and that the server returns an infinite amount of responses.</p></div></div></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">4<span class="lastDot dot">.</span></span></span>Examples</h1><div class="level1"><p><a href="#RFC1341" class="internal">RFC1341</a>The Multipart content type <a href="http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html" class="external">RFC section 7</a></p></div></div></div></div>

</body>
</html>