<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Channels 0.8</title>
<style><!-- 
body {
	margin-left: 10%;
	margin-right: 10%;
	padding: 20pt;
	padding-top: 10pt;
	background: rgb(255,255,255);
	font:  10.5pt/15pt "Helvetica",Helvetica,sans-serif;
	color: rgb(80,80,80);
}

h1, h2, h3, h4 {
	font-family: "Trebuchet MS",Helvetica,sans-serif;
	color: rgb(22, 130, 178);
	font-weight: normal;
	padding-top: 0.5em;
	cursor: pointer;
}

hr {
	color: rgb(150, 220, 238);
	background: rgb(150, 220, 238);
	height: 1px;
	border: 0;
}


b {
	color: rgb(22,130,178);
}

strong {
	color: rgb(103,183,0);
}


a:link, a:active, a:visited {
	color: rgb(22,130,178);
	text-decoration: none;
}

a:hover {
	text-decoration: none;
	background-color: #dbecf4;
}

aimg {
	border: 0;
}

#header, #footer {
	font-size: 7pt;
	clear: both;
	width: 100%;
	color: rgb(177,208,223);
}

.kiwiContent {
	text-align: left;
}


#footer {
	padding-top:  30pt;
	text-align: right;
}

/*  Kiwi-specific  */

.title {
	margin-bottom: 0;
}

.kiwiMeta {
	max-width: 700px;
	padding: 5pt;
	margin-bottom:  2em;
	border-top:  1px solid rgb(150, 220, 238);
	background-color: rgb(250,250,250);
}

.kiwiMeta tr td {
	color: rgb(22, 130, 178);
}

.kiwiMeta tr td.name {
	font-weight: bold;
}

.kiwiContent {
	max-width: 700px;
}

.kiwiContent .heading .number {
	padding-right: 8pt;
}

.kiwiContent .heading .number .lastDot {
	display: none;
}


.kiwiContent .heading .number .level0 .lastDot {
	display: inline;
}

.kiwiContent h1 {
	font-size: 1.8em;
	font-weight: bold;
	margin-top: 1.5em;
	padding-bottom: 0.5em;
	border-bottom:  1px dotted rgb(150, 220, 238);
}

.kiwiContent h2 {
	font-size: 1.4em;
	font-weight: bold;
	padding-bottom: 0.5em;
	border-bottom:  1px dotted rgb(150, 220, 238);
}

.kiwiContent h3 {
	font-size: 1.2em;
	font-weight: normal;
}

.kiwiContent pre {
	padding: 5pt;
	border:  1px solid rgb(150, 220, 238);
	padding-left: 20pt;
	background-color: rgb(240,240,250);
	font-size: 8pt;
	color: rgb(22,130,178);
}

.kiwiContent code {
	font-size: 8pt;
	background-color: rgb(240,240,250);
}

.kiwiContent dt {
	color: rgb(22,130,178);
	font-weight: bold;
}

.kiwiContent dd {
	border-left:  1px solid rgb(150, 220, 238);
	padding-left: 20pt;
	margin-bottom: 2em;
}

.kiwiContent dd pre {
}

.kiwiContent ul {
	padding-top: 0em;
	margin-top: 0em;
}

.kiwiContent ul li {
	padding-bottom: 0.2em;
}

.kiwiContent ul li.todo {
	list-style-type: square;
}

.kiwiContent ul li.todo.done {
	text-decoration: line-through;
}

.kiwiContent table {
	border:  1px solid rgb(150, 220, 238);
	padding: 0pt;
}

.kiwiContent table caption {
	font-family: serif;
	padding-top: 1em;
	padding-bottom: 0.5em;
	font-style: italic;
	font-size: 90%;
	color: rgb(22, 130, 178);
}

.kiwiContent table tbody {
}

.kiwiContent table tr {
	margin: 0;
}

.kiwiContent table tr td {
	margin: 0;
	padding: 5pt;
	font-size: 90%;
	min-width: 125px;
	background-color: rgb(250,250,250);
	border-bottom: 1px solid rgb(150, 220, 238);
}

.kiwiContent table tr td.lastRow {
	border-bottom: none;
}

.kiwiContent table tr td.lastCol {
	border-right: none;
}

.kiwiContent table tr.even td {
	background-color: #FEFEFE;

}

.kiwiContent table tr.odd td {
	background-color: rgb(240,240,240);
}

.kiwiContent .term {
	color: rgb(22, 130, 178);
	background: rgb(240, 250, 256);
}

.kiwiContent .quote {
	font-style: italic;
	color: rgb(120, 120, 120);
}

.kiwiContent .citation {
	font-style: italic;
	color: rgb(120, 120, 120);
}

.kiwiContent div[class^="ann"] {
	margin-top: 5pt;
	margin-bottom: 5pt;
	padding: 5pt;
	padding-left: 20pt;
	color: rgb(100, 100, 100);
}

.kiwiContent div[class^="ann"] .title {
	font-weight: bold;
}

.kiwiContent .annNote {
	border:  1px solid rgb(103,183,0);
	margin-top: 5pt;
	margin-bottom: 5pt;
	padding: 5pt;
	padding-left: 20pt;
	background: #fffbe4;
	color: rgb(100, 100, 100);
	border:  1px solid #dedac3;
}

.kiwiContent .annNote .title {
	font-weight: bold;
	display: none;
}

.kiwiReferences {
	font:  8pt/12pt "Lucida Grande",Lucida,sans-serif;
	margin-top: 10pt;
	padding: 5pt;
	border-top:  1px solid rgb(200, 200, 200);
	background-color: rgb(250,250,250);
	color: rgb(200, 200, 200);
	font-size: 8pt;
}
.kiwiReferences a:link, .kiwiReferences a:active, .kiwiReferences a:visited {
	color: rgb(150,150,150);
}

.kiwiReferences .entry {
	padding-top: 5pt;
	clear: both;
}

.kiwiReferences .entry .name {
	float: left;
	font-weight: bold;
	padding-right: 5pt;
}

.kiwiReferences .entry .content {
	text-align: right;
}

 --></style>
</head>
<body>
<div
	class="title"><h1>Channels 0.8</h1><h2>Developer Manual</h2></div><table class='kiwiMeta'><tr><td width='0px' class='name'>Author</td><td width='100%' class='value'>Sebastien Pierre &lt;sebastien@ivy.fr&gt;</td></tr><tr><td width='0px' class='name'>Revision</td><td width='100%' class='value'>12-Nov-2007</td></tr></table>
<div class="kiwiContent"><div class='content'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span>The problem</h1><div class="level1"></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">2<span class="lastDot dot">.</span></span></span>Channels API</h1><div class="level1"><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">1<span class="lastDot dot">.</span></span></span>Futures API</h2><div class="level2"><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">1<span class="dot">.</span></span><span class="level2">1<span class="lastDot dot">.</span></span></span>Channels API</h3><div class="level3"></div></div></div></div></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">3<span class="lastDot dot">.</span></span></span>Burst Channel Protocol</h1><div class="level1"><p>Burst channels is an easy way to do HTTP tunneling over HTTP. The idea is that when you have a lot of tiny requests to send to the server, it is may be better to group them as a larger request, so that you don't pay the overhead of multiplied latency.</p><p>For instance, if you have to send 10 requests, and you have a 100ms latency to the server, you'll end up having 1000ms total latency, while when using burst channels, you could keep the 100ms latency.</p><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">1<span class="lastDot dot">.</span></span></span>Request format</h2><div class="level2"><p>The Burst Channel protocol is modeled after the MIME RFC <a href="#RFC1341" class="internal">RFC1341</a>]. The idea is that the client will simply embed each request as an individual body in a <span class='term'>composite request</span>.</p><pre>+---------------------------------------------------------------+
| GET         /url/supporting/burst/channel                     |
+---------------------------------------------------------------+
| Content-Type: multipart/mixed;boundary=BURST-q0M2Yt08jU534c0p |
| X-Channel-Type: burst                                         |
| X-Channel-Requests: 4                                         |
+---------------------------------------------------------------+
| HTTP REQUEST 1                                                |
| ............................................................. |
| boundary=BURST-q0M2Yt08jU534c0p                               |
| ............................................................. |
| HTTP REQUEST 2                                                |
| ............................................................. |
| boundary=BURST-q0M2Yt08jU534c0p                               |
| ............................................................. |
| HTTP REQUEST 4                                                |
+---------------------------------------------------------------+</pre><p>Each HTTP request is given as-is, including request URI, headers and body. The only thing to watch for is to avoid conflicts in boundaries, which is why the separator should start with <code>BURST-</code> (which makes it easier to disambiguate).</p><p>Aside from that, it is a good idea to add an <code>X-Channel-Type:burst</code> header to the requests headers, just to be more explicit (and give a chance to reverse proxies to direct the burst requests to the appropriate server)&ndash;but it should not be required by servers.</p><p>The optional <code>X-Channel-Requests</code> field can also be added to indicate how many requests are expected to be found in the request bodies. This is only useful for debugging purposes, as HTTP requests are expected to arrive completely.</p><p>There is no other particular requirement for the URL either, it is more a matter of convention. It's generally OK to provide a single URL that processes burst channels requests. In some cases, you might prefer to partition your site and provide different URLs that can handle burst channels.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">2<span class="lastDot dot">.</span></span></span>Response format</h2><div class="level2"><p>Symetrically to the request, the response will contain embedded HTTP responses to the embedded HTTP requests. The only constraint to respect here is to make sure the ordering of responses is the same as the ordering of requests.</p><pre>+---------------------------------------------------------------+
| HTTP 200 OK                                                   |
+---------------------------------------------------------------+
| Content-Type: multipart/mixed;boundary=BURST-q0M2Yt08jU534c0p |
| X-Channel-Responses: 4                                        |
+---------------------------------------------------------------+
| HTTP RESPONSE 1                                               |
| ............................................................. |
| boundary=BURST-q0M2Yt08jU534c0p                               |
| ............................................................. |
| HTTP RESPONSE 2                                               |
| ............................................................. |
| boundary=BURST-q0M2Yt08jU534c0p                               |
| ............................................................. |
| HTTP RESPONSE 4                                               |
+---------------------------------------------------------------+</pre><p>The optional <code>X-Channel-Responses</code> plays the same role as <code>X-Channel-Requests</code> and is only useful for debugging purposes.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">3<span class="lastDot dot">.</span></span></span>Expected client behaviour</h2><div class="level2"><p>The client can choose whether he wants to send the request all at once or if he will "stream" the bodies, meaning that there may be some delay between the sending of each body. However, this is unlikely to happen as web browsers do not support streaming of request bodies.</p><p>Clients should take advantage of response streaming and start to process the responses even if all the responses have not been received.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">4<span class="lastDot dot">.</span></span></span>Expected server behaviour</h2><div class="level2"><p>Conversely, the server can choose between waiting for all the requests to be processed to before sending the response, or to send the responses as soon as they are available, provided the ordering is kept.</p><p>The optimal behaviour would be to start processing the requests as soon as they are available, and to stream the responses as soon as they are available and in order.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">5<span class="lastDot dot">.</span></span></span>Possible extensions</h2><div class="level2"><p>One of the obvious extensions to burst channels is to do simple HTTP streaming, where the client sends only one request, and that the server returns an infinite amount of responses.</p></div></div></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">4<span class="lastDot dot">.</span></span></span>Examples</h1><div class="level1"><p><a href="#RFC1341" class="internal">RFC1341</a>The Multipart content type <a href="http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html" class="external">RFC section 7</a></p></div></div></div></div>

</body>
</html>