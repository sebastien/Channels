<html>
<!-- Document generated by SDoc <http://www.ivy.fr/sdoc> -->
<head>
<title>None</title>
<!-- snip-snip-snip-snip-snip-snip -->
<style type="text/css" media="screen">
/* css-main-snip */
html, body {
	background : #fcfcf6;
	color: #000000;
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	padding: 0;
	margin: 0;
}


a, a:active, a:link, a:visited, a:hover {
	color: #404040;
	text-decoration: none;
}

a:active, a:focus {
	background-color: #eae08c;
	color: white;
	border: 0;
	padding: 2px;
}

a:hover {
	color: #8fb216;
}

code {
	color: #8fb216;
}

pre {
	padding-top: 5pt;
	padding-bottom: 5pt;
	background: #f0f0f0;
	color: #8fb216;
}

/* css-main-snip */
/* css-classes-snip */
#descriptions {
	padding: 0;
	margin: 0;
	margin-left: 380px;
}

#modules {
	padding: 0;
	padding: 1pt;
	padding-left: 5pt;
	font-size: 7pt;
	color: #A0A0A0;
	background: #404040;
	border-bottom: 2px solid #f0f0f0;
}

#modules a {
	color: white;
}

#api {
	display: block;
	width: 360px;
	float: left;
	padding:0;
	padding-left: 5pt;
	padding-right: 10pt;
	background: white;
	border-right: 1px solid #f0f0f0;
	overflow: auto;
	height: 100%;

}

#hidden {
	padding: 0;
	margin: 0;
	display: none;
}

#sdoc .description {
	display: none;
	padding: 5pt;
}

#sdoc .representation {
	padding-bottom: 5pt;
}


#sdoc .title {
	padding-top: 10pt;
	font-weight: bold;
	border-bottom: 1px solid #f0f0f0;
	color: #505050;
}

#sdoc .prefix {
	color: #D0C0C0;
	font-style: italic;
	padding-right: 5px;
}

#sdoc .noattributes {
	color: #D0C0C0;
	font-style: italic;
}

#sdoc .name, #sdoc .name a {
	color: #cdb425;
}

#sdoc .term {
	font-weight:bold;
	color: #cdb425;
	background: #F9FFDE;
	padding-left: 2px;
	padding-right: 2px;
}

#sdoc .name {
	font-weight: bold;
	margin-top: 1em;
}

#sdoc .special {
	font-weight: bold;
}

#sdoc .special.__bases__ {
	font-weight: normal;
	color: #cdb425;
}

#sdoc .undocumented, #sdoc .undocumented a {
	color: #b0c0c0;
	font-style: italic;
}
#sdoc .docstring {
	border-top: 1px solid #f0f0f0;
	border-bottom: 1px solid #f0f0f0;
	background: white;
	padding: 5pt;
	color: #808080;
}

#sdoc table caption {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	font-weight: bold;
}

#sdoc table tr td {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	color: #808080;
}

#sdoc .root, #sdoc .container {
	padding-left: 10pt;
	padding-top: 8pt;
	color: #404040;
	width: 150px;
	border-left: 1px solid #f0f0f0;
	float: left;
}

#sdoc .container {
	margin-left: 10pt;
	display: none;
}


/* css-classes-snip */
</style>
<!-- snip-snip-snip-snip-snip-snip -->
<script type="text/javascript">
// javascript-snip

var displays    = [];
var selected    = undefined;
var description = undefined;
var hidden      = undefined;
var content     = undefined;

function documentElement( from_id, to_id )
{
	if ( to_id == undefined ) { to_id = from_id ; from_id = undefined; }
	if ( hidden  == undefined ) hidden  = document.getElementById("hidden");
	if ( content == undefined ) content = document.getElementById("api");
	// We get the target element and the associated description element
	var element  = document.getElementById(to_id);
	var felement = document.getElementById(from_id);
	var level    = 0;
	if ( felement != undefined )
	{
		level        = felement.getAttribute("level");
		if ( !level ) { level = 0; }
		else { level = parseInt(level); }
	}
	else
	{
		level = 0;
	}
	// We show the element description
	describeElement(to_id);
	// We show the element
	if (element)
	{
		if ( element == selected ) return;
		// We re-order the content nodes anyway
		element.parentNode.removeChild(element);
		element.setAttribute("level", level + 1);
		content.appendChild(element);
		// Ensure that the node is visible
		element.style.display  = "block";
		// And its description
		// We hide the old ones
		while ( displays.length > 0 && displays.length > level )
		{
			var hiding_id = displays.pop()
			var hiding_el = document.getElementById(hiding_id);
			if ( hiding_el != element )
			{
				hiding_el.parentNode.removeChild(hiding_el);
				hidden.appendChild(hiding_el);
			}
		}
		// And update the state
		displays.push(to_id);
		selected = element;
	}
}

function describeElement( eid )
{
	var delement = document.getElementById("d_" + eid);
	if ( delement != undefined && delement != description )
	{
		delement.style.display = "block";
		if ( description != undefined ) description.style.display = "none";
		description = delement;
	}
	else if ( delement == undefined )
	{
		alert("ERROR: Description not found for id 'd_" + eid + "'");
	}
}
// javascript-snip
<!-- snip-snip-snip-snip-snip-snip -->
</script>
</head>
<body onLoad="javascript:documentElement('a');">
<!-- body -->
<div id="sdoc">
<div id='modules'>
<!-- modules-snip -->
API : <a href='javascript:documentElement("a");'>channels</a>
<!-- modules-snip -->
</div>
<div id='api'><!-- main element will be displayed here --></div>
<div id='descriptions'>
	<!-- descriptions-snip -->
	<div id='d_c' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_b' class='description'><h1>Class <span class='name'>AsyncChannel</span></h1><div class='representation'></div><div class='docstring'><p>The AsyncChannel will use the asynchronous methods from the HTTP transport object to do the communication.</p></div></div><div id='d_e' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_f' class='description'><h1>Method <span class='name'>_createFuture</span></h1><div class='representation'></div><div class='docstring'><p>Returns a new future, properly initialized for this channel</p></div></div><div id='d_g' class='description'><h1>Method <span class='name'>_encodeURI</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_h' class='description'><h1>Method <span class='name'>_futureHasFailed</span></h1><div class='representation'></div><div class='docstring'><p>Invoked when a future has failed. This invokes every callback registered in the <code>failureCallbacks</code> list (which were previously registered using the 'onFail' method).</p></div></div><div id='d_i' class='description'><h1>Method <span class='name'>_normalizeBody</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_j' class='description'><h1>Method <span class='name'>_parseJSON</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_k' class='description'><h1>Method <span class='name'>_processHTTPResponse</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_l' class='description'><h1>Method <span class='name'>_responseIsJSON</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_m' class='description'><h1>Method <span class='name'>get</span></h1><div class='representation'></div><div class='docstring'><p>Invokes a <code>GET</code> to the given url (prefixed by the optional <code>prefix</code> set in this channel options) and returns a <code>Future</code>.</p><p>The future is already bound with a <code>refresh</code> callback that will do the request again.</p></div></div><div id='d_n' class='description'><h1>Method <span class='name'>onFail</span></h1><div class='representation'></div><div class='docstring'><p>Sets a callback that will be invoked when a future created in this channel fails. The given <code>callback</code> takes the <span class='term'>reason</span>, <span class='term'>details</span> and <span class='term'>future</span> as argument, where reason and details are application-specific information (for HTTP, reason is usually a number, detail is the response text)</p></div></div><div id='d_o' class='description'><h1>Method <span class='name'>post</span></h1><div class='representation'></div><div class='docstring'><p>Invokes a <code>POST</code> to the give url (prefixed by the optional <code>prefix</code> set in this channel options), using the given <code>body</code> as request body, and returning a <code>Future</code> instance.</p><p>The future is already bound with a <code>refresh</code> callback that will do the request again.</p></div></div><div id='d_p' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_q' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_r' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_d' class='description'><h1>Class <span class='name'>Channel</span></h1><div class='representation'></div><div class='docstring'><p>Channels are specific objects that allow communication operations to happen in a shared context. The modus operandi is as follows:</p><ul><li>You initialize a channel with specific properties (for HTTP, this would be a prefix for the URLs, wether you want to evaluate the JSON that may be contained in responses, etc). </li><li>You send something into the channel (typically an HTTP request) </li><li>You get a <code>Future</code> as a promise for a future result. </li><li>When the result arrives, the future is set with the resulting value.</li></ul><p>Synchronous channels will typically set the result directly, while for asynchronous channels, the result will only be available later.</p><p>NOTE: The current implementation of <code>Channels</code> is very much HTTP-oriented. At a later point, the Channels class will be more generic, and will provide separate specific aspects for the HTTP protocol.</p></div></div><div id='d_t' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_u' class='description'><h1>Method <span class='name'>fail</span></h1><div class='representation'></div><div class='docstring'><p>Fails this future with the given (optional) <code>reason</code> and <code>details</code>. The 'reason' should be a value from the 'REASONS' dictionary, and the context an object (probably a dictionary) that gives more detailed information on the failure.</p><pre>future fail ( "timeout", 2000 )</pre><p>Could mean to the application that the future failed because the timeout value of 2000 was reached.</p></div></div><div id='d_v' class='description'><h1>Method <span class='name'>get</span></h1><div class='representation'></div><div class='docstring'><p>This is an alias for <code>value</code></p></div></div><div id='d_w' class='description'><h1>Method <span class='name'>getErrorDetails</span></h1><div class='representation'></div><div class='docstring'><p>Returns the details for the error. This is only set when the future has failed.</p></div></div><div id='d_x' class='description'><h1>Method <span class='name'>getErrorReason</span></h1><div class='representation'></div><div class='docstring'><p>Returns the reason for the error. This is only set when the future has failed.</p></div></div><div id='d_y' class='description'><h1>Method <span class='name'>hasFailed</span></h1><div class='representation'></div><div class='docstring'><p>Tells if this future has failed or not</p></div></div><div id='d_z' class='description'><h1>Method <span class='name'>hasSucceeded</span></h1><div class='representation'></div><div class='docstring'><p>Tells if this future has succeeded or not (this is an alias for <code>isSet</code>)</p></div></div><div id='d_A' class='description'><h1>Method <span class='name'>isSet</span></h1><div class='representation'></div><div class='docstring'><p>Tells if this future value was set or not.</p></div></div><div id='d_B' class='description'><h1>Method <span class='name'>onFail</span></h1><div class='representation'></div><div class='docstring'><p>Registers the given callback to be invoked when this future fails. The callback will take the error reason and error details as first two arguments, and the future as third argument.</p><pre> future onFail {r,d,f| print ("Future", f, "failed: reason is ", r, ", ", d)}</pre></div></div><div id='d_C' class='description'><h1>Method <span class='name'>onRefresh</span></h1><div class='representation'></div><div class='docstring'><p>Sets the callback that will be invoked with this future as argument when the <code>refresh</code> method is invoked. There can be only one refresh callback per future, which means that the previous refresh function will be replaced by the newly given callback.</p><p>See <code>refresh</code> for an example.</p></div></div><div id='d_D' class='description'><h1>Method <span class='name'>onSet</span></h1><div class='representation'></div><div class='docstring'><p>Registers the given callback to be invoked when this future value is set. The callback will take the value as first argument and the future as second argument.</p><pre> future onSet {v,f| print ("Received value", v, "from future", f)}</pre></div></div><div id='d_E' class='description'><h1>Method <span class='name'>process</span></h1><div class='representation'></div><div class='docstring'><p>Adds a callback that will process the value of this future, returning the newly processed value. Processing callback will be chained, and will work even if the future value is already set.</p><p>Processors are typically used to process the value obtained from a future.</p><pre> var future = getFutureResult()
 future process { v | v toLowerCase() }
 future onSet   { v | print ("Lowercase value: " + v) }</pre><p>It is a good idea to use processors along with the <code>refresh</code> option, so that you can easily set up a chain of processing the future value.</p></div></div><div id='d_F' class='description'><h1>Method <span class='name'>refresh</span></h1><div class='representation'></div><div class='docstring'><p>Refreshing a feature will basically invoke the <code>refresh</code> callback set with the <code>onRefresh</code> function. Typical use of <code>refresh</code> is to take an existing future and to bind the function that created the value as 'refresh', so that getting a "fresher" value can simply be done by calling 'refresh'.</p><p>Example:</p><pre> var i = 0
 var f = new Future()
 var p = { f set (i) ; i += 1 }
 f onRefresh (p)
 p()
 print ("i =", f get())
 f refresh()
 print ("i =", f get())
 f refresh()
 print ("i =", f get())</pre><p>Will print</p><pre> i = 0
 i = 1
 i = 2</pre></div></div><div id='d_G' class='description'><h1>Method <span class='name'>set</span></h1><div class='representation'></div><div class='docstring'><p>Sets the value for this future. This function can be given as a callback for an underlying asynchronous system (such as MochiKit Defered).</p></div></div><div id='d_H' class='description'><h1>Method <span class='name'>value</span></h1><div class='representation'></div><div class='docstring'><p>Returns the value for this future. This will return <code>Undefined</code> until the value is set. If you want to know if the value is set you can query the 'state' property of the future or invoke the 'isSet' method.</p></div></div><div id='d_I' class='description'><h1>ClassAttribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_J' class='description'><h1>ClassAttribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_K' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_L' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_M' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_N' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_O' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_P' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Q' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_R' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_s' class='description'><h1>Class <span class='name'>Future</span></h1><div class='representation'></div><div class='docstring'><p>A Future represents the promise of a future value returned by an invocation that started an asynchronous process. In other words, a future is a value that &ldquo;<span class='quote'>wraps the future value</span>&rdquo; that will be later returned by a process that is not able to give the value directly.</p><p>The typical use of Futures is when you are doing networking, such as asynchronous HTTP GETs on a web client: you won't have the response directly (because the HTTP GET is synchronous) but you may want to do things in the meantime.</p><p>Futures provide an interesting abstraction to deal with these situations. This implementation of Futures was inspired from the Oz programming language.</p></div></div><div id='d_T' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_U' class='description'><h1>Method <span class='name'>_createRequest</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_V' class='description'><h1>Method <span class='name'>_processRequest</span></h1><div class='representation'></div><div class='docstring'><p>Processes the given HTTP request, taking into account the following 'options':</p><ul><li><code>method</code>, the HTTP method (<code>GET</code>, <code>POST</code>, in uppercase) </li><li><code>url</code>, the requested url </li><li><code>asynchronous</code> (default <code>True</code>), to indicate wether the request should be made in synchronous or asynchronous mode </li><li><code>body</code> (default is <code>""</code>) the optional request body </li><li><code>headers</code> is a dictionary of headers to add to the request </li><li><code>success</code>, the callback that will be invoked on success, with the request as argument </li><li><code>failure</code>, the callback that will be invoked on failure, with the request argument </li></ul></div></div><div id='d_W' class='description'><h1>Method <span class='name'>asyncGet</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_X' class='description'><h1>Method <span class='name'>asyncPost</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Y' class='description'><h1>Method <span class='name'>syncGet</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Z' class='description'><h1>Method <span class='name'>syncPost</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_ab' class='description'><h1>ClassAttribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_S' class='description'><h1>Class <span class='name'>HTTPTransport</span></h1><div class='representation'></div><div class='docstring'><p>The <code>HTTPTransport</code> is the low-level class used by channels to do HTTP communication. This class really acts as a wrapper for platform-specific HTTP communication implementations, taking care of returning <code>Futures</code> instances to be used by the channels.</p><p>All the futures returned by the HTTPTransport will give the HTTP request object as-is. Particularly, the <code>Channels</code></p></div></div><div id='d_cb' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_bb' class='description'><h1>Class <span class='name'>SyncChannel</span></h1><div class='representation'></div><div class='docstring'><p>The SyncChannel will use the synchronous methods from the HTTP transport object to do the communication.</p></div></div><div id='d_a' class='description'><h1>Module <span class='name'>channels</span></h1><div class='representation'></div><div class='docstring'><p>The channels module defines objects that make JavaScript client-side HTTP communication easier by providing the <code>Future</code> and <code>Channel</code> abstractions well known from some concurrent programming languages and frameworks.</p></div></div>
	<!-- descriptions-snip -->
</div>
<div id='hidden'>
	<!-- hidden-snip -->
	<div id='S' class='container'><div class='name'><a href='javascript:describeElement("S");'>HTTPTransport</a></div><div class='title'>Methods</div class='title'><div class='group'><span class='undocumented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("S","T");'><span class='special __init__'>constructor</span></a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("S","U");'>_createRequest</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("S","V");'>_processRequest</a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("S","W");'>asyncGet</a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("S","X");'>asyncPost</a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("S","Y");'>syncGet</a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("S","Z");'>syncPost</a></span><br /></div><div class='title'>Values</div class='title'><div class='group'><span class='undocumented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("S","ab");'>DEFAULT</a></span><br /></div></div><div id='d_bb' class='description'><h1>Class <span class='name'>SyncChannel</span></h1><div class='representation'></div><div class='docstring'><p>The SyncChannel will use the synchronous methods from the HTTP transport object to do the communication.</p></div></div><div id='d_X' class='description'><h1>Method <span class='name'>asyncPost</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_ab' class='description'><h1>ClassAttribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='s' class='container'><div class='name'><a href='javascript:describeElement("s");'>Future</a></div><div class='title'>Methods</div class='title'><div class='group'><span class='undocumented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("s","t");'><span class='special __init__'>constructor</span></a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","u");'>fail</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","v");'>get</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","w");'>getErrorDetails</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","x");'>getErrorReason</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","y");'>hasFailed</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","z");'>hasSucceeded</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","A");'>isSet</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","B");'>onFail</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","C");'>onRefresh</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","D");'>onSet</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","E");'>process</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","F");'>refresh</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","G");'>set</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("s","H");'>value</a></span><br /></div><div class='title'>Values</div class='title'><div class='group'><span class='undocumented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("s","I");'>REASONS</a></span><br /><span class='undocumented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("s","J");'>STATES</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("s","K");'>_errorDetails</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("s","L");'>_errorReason</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("s","M");'>_onFail</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("s","N");'>_onRefresh</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("s","O");'>_onSet</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("s","P");'>_processors</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("s","Q");'>_value</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("s","R");'>state</a></span><br /></div></div><div id='d_cb' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Z' class='description'><h1>Method <span class='name'>syncPost</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='a' class='root'><div class='name'><a href='javascript:describeElement("a");'>channels</a></div><div class='title'>Classes</div class='title'><div class='group'><span class='documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","b");'>AsyncChannel</a></span><br /><span class='documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","d");'>Channel</a></span><br /><span class='documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","s");'>Future</a></span><br /><span class='documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","S");'>HTTPTransport</a></span><br /><span class='documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","bb");'>SyncChannel</a></span><br /></div></div><div id='d_I' class='description'><h1>ClassAttribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Y' class='description'><h1>Method <span class='name'>syncGet</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='bb' class='container'><div class='name'><a href='javascript:describeElement("bb");'>SyncChannel</a></div><div class='title'>Methods</div class='title'><div class='group'><span class='undocumented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("bb","cb");'><span class='special __init__'>constructor</span></a></span><br /></div></div><div id='d_R' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_S' class='description'><h1>Class <span class='name'>HTTPTransport</span></h1><div class='representation'></div><div class='docstring'><p>The <code>HTTPTransport</code> is the low-level class used by channels to do HTTP communication. This class really acts as a wrapper for platform-specific HTTP communication implementations, taking care of returning <code>Futures</code> instances to be used by the channels.</p><p>All the futures returned by the HTTPTransport will give the HTTP request object as-is. Particularly, the <code>Channels</code></p></div></div><div id='d_P' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Q' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_V' class='description'><h1>Method <span class='name'>_processRequest</span></h1><div class='representation'></div><div class='docstring'><p>Processes the given HTTP request, taking into account the following 'options':</p><ul><li><code>method</code>, the HTTP method (<code>GET</code>, <code>POST</code>, in uppercase) </li><li><code>url</code>, the requested url </li><li><code>asynchronous</code> (default <code>True</code>), to indicate wether the request should be made in synchronous or asynchronous mode </li><li><code>body</code> (default is <code>""</code>) the optional request body </li><li><code>headers</code> is a dictionary of headers to add to the request </li><li><code>success</code>, the callback that will be invoked on success, with the request as argument </li><li><code>failure</code>, the callback that will be invoked on failure, with the request argument </li></ul></div></div><div id='d_W' class='description'><h1>Method <span class='name'>asyncGet</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_T' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_U' class='description'><h1>Method <span class='name'>_createRequest</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_J' class='description'><h1>ClassAttribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_K' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_H' class='description'><h1>Method <span class='name'>value</span></h1><div class='representation'></div><div class='docstring'><p>Returns the value for this future. This will return <code>Undefined</code> until the value is set. If you want to know if the value is set you can query the 'state' property of the future or invoke the 'isSet' method.</p></div></div><div id='d_y' class='description'><h1>Method <span class='name'>hasFailed</span></h1><div class='representation'></div><div class='docstring'><p>Tells if this future has failed or not</p></div></div><div id='d_N' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_O' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_L' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_M' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_B' class='description'><h1>Method <span class='name'>onFail</span></h1><div class='representation'></div><div class='docstring'><p>Registers the given callback to be invoked when this future fails. The callback will take the error reason and error details as first two arguments, and the future as third argument.</p><pre> future onFail {r,d,f| print ("Future", f, "failed: reason is ", r, ", ", d)}</pre></div></div><div id='d_C' class='description'><h1>Method <span class='name'>onRefresh</span></h1><div class='representation'></div><div class='docstring'><p>Sets the callback that will be invoked with this future as argument when the <code>refresh</code> method is invoked. There can be only one refresh callback per future, which means that the previous refresh function will be replaced by the newly given callback.</p><p>See <code>refresh</code> for an example.</p></div></div><div id='d_A' class='description'><h1>Method <span class='name'>isSet</span></h1><div class='representation'></div><div class='docstring'><p>Tells if this future value was set or not.</p></div></div><div id='d_F' class='description'><h1>Method <span class='name'>refresh</span></h1><div class='representation'></div><div class='docstring'><p>Refreshing a feature will basically invoke the <code>refresh</code> callback set with the <code>onRefresh</code> function. Typical use of <code>refresh</code> is to take an existing future and to bind the function that created the value as 'refresh', so that getting a "fresher" value can simply be done by calling 'refresh'.</p><p>Example:</p><pre> var i = 0
 var f = new Future()
 var p = { f set (i) ; i += 1 }
 f onRefresh (p)
 p()
 print ("i =", f get())
 f refresh()
 print ("i =", f get())
 f refresh()
 print ("i =", f get())</pre><p>Will print</p><pre> i = 0
 i = 1
 i = 2</pre></div></div><div id='d_G' class='description'><h1>Method <span class='name'>set</span></h1><div class='representation'></div><div class='docstring'><p>Sets the value for this future. This function can be given as a callback for an underlying asynchronous system (such as MochiKit Defered).</p></div></div><div id='d_D' class='description'><h1>Method <span class='name'>onSet</span></h1><div class='representation'></div><div class='docstring'><p>Registers the given callback to be invoked when this future value is set. The callback will take the value as first argument and the future as second argument.</p><pre> future onSet {v,f| print ("Received value", v, "from future", f)}</pre></div></div><div id='d_E' class='description'><h1>Method <span class='name'>process</span></h1><div class='representation'></div><div class='docstring'><p>Adds a callback that will process the value of this future, returning the newly processed value. Processing callback will be chained, and will work even if the future value is already set.</p><p>Processors are typically used to process the value obtained from a future.</p><pre> var future = getFutureResult()
 future process { v | v toLowerCase() }
 future onSet   { v | print ("Lowercase value: " + v) }</pre><p>It is a good idea to use processors along with the <code>refresh</code> option, so that you can easily set up a chain of processing the future value.</p></div></div><div id='d_z' class='description'><h1>Method <span class='name'>hasSucceeded</span></h1><div class='representation'></div><div class='docstring'><p>Tells if this future has succeeded or not (this is an alias for <code>isSet</code>)</p></div></div><div id='d_x' class='description'><h1>Method <span class='name'>getErrorReason</span></h1><div class='representation'></div><div class='docstring'><p>Returns the reason for the error. This is only set when the future has failed.</p></div></div><div id='b' class='container'><div class='name'><a href='javascript:describeElement("b");'>AsyncChannel</a></div><div class='title'>Methods</div class='title'><div class='group'><span class='undocumented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("b","c");'><span class='special __init__'>constructor</span></a></span><br /></div></div><div id='d' class='container'><div class='name'><a href='javascript:describeElement("d");'>Channel</a></div><div class='title'>Methods</div class='title'><div class='group'><span class='undocumented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("d","e");'><span class='special __init__'>constructor</span></a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","f");'>_createFuture</a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","g");'>_encodeURI</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","h");'>_futureHasFailed</a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","i");'>_normalizeBody</a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","j");'>_parseJSON</a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","k");'>_processHTTPResponse</a></span><br /><span class='undocumented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","l");'>_responseIsJSON</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","m");'>get</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","n");'>onFail</a></span><br /><span class='documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("d","o");'>post</a></span><br /></div><div class='title'>Values</div class='title'><div class='group'><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("d","p");'>failureCallbacks</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("d","q");'>options</a></span><br /><span class='undocumented'><span
					class='prefix'>&sdot;</span><a href='javascript:documentElement("d","r");'>transport</a></span><br /></div></div><div id='d_r' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_s' class='description'><h1>Class <span class='name'>Future</span></h1><div class='representation'></div><div class='docstring'><p>A Future represents the promise of a future value returned by an invocation that started an asynchronous process. In other words, a future is a value that &ldquo;<span class='quote'>wraps the future value</span>&rdquo; that will be later returned by a process that is not able to give the value directly.</p><p>The typical use of Futures is when you are doing networking, such as asynchronous HTTP GETs on a web client: you won't have the response directly (because the HTTP GET is synchronous) but you may want to do things in the meantime.</p><p>Futures provide an interesting abstraction to deal with these situations. This implementation of Futures was inspired from the Oz programming language.</p></div></div><div id='d_p' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_q' class='description'><h1>Attribute</h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_v' class='description'><h1>Method <span class='name'>get</span></h1><div class='representation'></div><div class='docstring'><p>This is an alias for <code>value</code></p></div></div><div id='d_w' class='description'><h1>Method <span class='name'>getErrorDetails</span></h1><div class='representation'></div><div class='docstring'><p>Returns the details for the error. This is only set when the future has failed.</p></div></div><div id='d_t' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_u' class='description'><h1>Method <span class='name'>fail</span></h1><div class='representation'></div><div class='docstring'><p>Fails this future with the given (optional) <code>reason</code> and <code>details</code>. The 'reason' should be a value from the 'REASONS' dictionary, and the context an object (probably a dictionary) that gives more detailed information on the failure.</p><pre>future fail ( "timeout", 2000 )</pre><p>Could mean to the application that the future failed because the timeout value of 2000 was reached.</p></div></div><div id='d_j' class='description'><h1>Method <span class='name'>_parseJSON</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_k' class='description'><h1>Method <span class='name'>_processHTTPResponse</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_h' class='description'><h1>Method <span class='name'>_futureHasFailed</span></h1><div class='representation'></div><div class='docstring'><p>Invoked when a future has failed. This invokes every callback registered in the <code>failureCallbacks</code> list (which were previously registered using the 'onFail' method).</p></div></div><div id='d_i' class='description'><h1>Method <span class='name'>_normalizeBody</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_n' class='description'><h1>Method <span class='name'>onFail</span></h1><div class='representation'></div><div class='docstring'><p>Sets a callback that will be invoked when a future created in this channel fails. The given <code>callback</code> takes the <span class='term'>reason</span>, <span class='term'>details</span> and <span class='term'>future</span> as argument, where reason and details are application-specific information (for HTTP, reason is usually a number, detail is the response text)</p></div></div><div id='d_o' class='description'><h1>Method <span class='name'>post</span></h1><div class='representation'></div><div class='docstring'><p>Invokes a <code>POST</code> to the give url (prefixed by the optional <code>prefix</code> set in this channel options), using the given <code>body</code> as request body, and returning a <code>Future</code> instance.</p><p>The future is already bound with a <code>refresh</code> callback that will do the request again.</p></div></div><div id='d_l' class='description'><h1>Method <span class='name'>_responseIsJSON</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_m' class='description'><h1>Method <span class='name'>get</span></h1><div class='representation'></div><div class='docstring'><p>Invokes a <code>GET</code> to the given url (prefixed by the optional <code>prefix</code> set in this channel options) and returns a <code>Future</code>.</p><p>The future is already bound with a <code>refresh</code> callback that will do the request again.</p></div></div><div id='d_b' class='description'><h1>Class <span class='name'>AsyncChannel</span></h1><div class='representation'></div><div class='docstring'><p>The AsyncChannel will use the asynchronous methods from the HTTP transport object to do the communication.</p></div></div><div id='d_c' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_a' class='description'><h1>Module <span class='name'>channels</span></h1><div class='representation'></div><div class='docstring'><p>The channels module defines objects that make JavaScript client-side HTTP communication easier by providing the <code>Future</code> and <code>Channel</code> abstractions well known from some concurrent programming languages and frameworks.</p></div></div><div id='d_f' class='description'><h1>Method <span class='name'>_createFuture</span></h1><div class='representation'></div><div class='docstring'><p>Returns a new future, properly initialized for this channel</p></div></div><div id='d_g' class='description'><h1>Method <span class='name'>_encodeURI</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_d' class='description'><h1>Class <span class='name'>Channel</span></h1><div class='representation'></div><div class='docstring'><p>Channels are specific objects that allow communication operations to happen in a shared context. The modus operandi is as follows:</p><ul><li>You initialize a channel with specific properties (for HTTP, this would be a prefix for the URLs, wether you want to evaluate the JSON that may be contained in responses, etc). </li><li>You send something into the channel (typically an HTTP request) </li><li>You get a <code>Future</code> as a promise for a future result. </li><li>When the result arrives, the future is set with the resulting value.</li></ul><p>Synchronous channels will typically set the result directly, while for asynchronous channels, the result will only be available later.</p><p>NOTE: The current implementation of <code>Channels</code> is very much HTTP-oriented. At a later point, the Channels class will be more generic, and will provide separate specific aspects for the HTTP protocol.</p></div></div><div id='d_e' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div>
	<!-- hidden-snip -->
	<!-- hidden nodes will be moved here -->
</div>
</div>
<!-- body -->
</body>
</html>
